---
description: Rust fundamental coding practices for mocks project
globs:
  - "**/*.rs"
alwaysApply: true
---

# Rust Fundamentals for Mocks Project

This rule defines fundamental Rust coding practices for the mocks CLI tool project.

## Error Handling Patterns

### Use Result<T, E> for Recoverable Errors
```rust
// Prefer explicit Result handling
fn parse_socket_addr(host: &str, port: u16) -> Result<SocketAddr, MocksError> {
    let ip_addr = if host == "localhost" { "127.0.0.1" } else { host };
    ip_addr
        .parse::<IpAddr>()
        .map(|ip| SocketAddr::from((ip, port)))
        .map_err(|e| MocksError::InvalidArgs(e.to_string()))
}
```

### Custom Error Types with Meaningful Context
```rust
// Use custom error types that map to HTTP status codes
match storage.operation() {
    Ok(result) => Ok(result),
    Err(MocksError::InvalidArgs(msg)) => {
        eprintln!("Hint: Run with --help to see usage information");
        Err(MocksError::InvalidArgs(msg))
    }
}
```

### Error Propagation with ?
```rust
// Use ? operator for clean error propagation
pub async fn startup(socket_addr: SocketAddr, storage: Storage) -> Result<(), MocksError> {
    let listener = TcpListener::bind(socket_addr)
        .await
        .map_err(|e| MocksError::Exception(e.to_string()))?;
    // ...
}
```

## Async/Await Patterns

### Tokio Runtime Usage
```rust
// Use #[tokio::main] for async main
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Async operations here
}
```

### Async Function Signatures
```rust
// Prefer explicit async return types
pub async fn startup(socket_addr: SocketAddr, storage: Storage) -> Result<(), MocksError> {
    // Implementation
}
```

### Awaiting Multiple Operations
```rust
// Use tokio::try_join! for concurrent operations when appropriate
let (result1, result2) = tokio::try_join!(
    operation1(),
    operation2()
)?;
```

## Memory Management Patterns

### Shared State with Arc<Mutex<T>>
```rust
// Use Arc<Mutex<T>> for thread-safe shared state
pub type SharedState = Arc<Mutex<AppState>>;

impl AppState {
    pub fn new(storage: Storage) -> SharedState {
        Arc::new(Mutex::new(AppState { storage }))
    }
}
```

### Clone Implementation for Shared Data
```rust
// Implement Clone for types that need to be shared
#[derive(Clone)]
pub struct Storage {
    pub file: String,
    pub data: StorageData,
    pub overwrite: bool,
}
```

### Avoiding Unnecessary Clones
```rust
// Pass references when ownership transfer isn't needed
fn process_data(data: &Value) -> Result<Vec<String>, MocksError> {
    // Process without taking ownership
}
```

## Serde Serialization Patterns

### Using Derive Macros
```rust
// Use derive macros for automatic serialization
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ResourceData {
    pub id: Option<String>,
    pub content: Value,
}
```

### Working with serde_json::Value
```rust
// Use Value for dynamic JSON handling
pub type StorageData = Value;
pub type Input = Value;

// Pattern match on Value types
if let Value::Object(obj) = &data {
    for (key, value) in obj {
        // Process key-value pairs
    }
}
```

### JSON Parsing with Error Handling
```rust
// Always handle JSON parsing errors
fn parse_json(content: &str) -> Result<Value, MocksError> {
    serde_json::from_str(content)
        .map_err(|e| MocksError::InvalidJson(format!("Failed to parse JSON: {}", e)))
}
```

## Clap CLI Patterns

### Using Derive API
```rust
// Use derive API for clean CLI definition
#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(clap::Subcommand, Debug)]
enum Commands {
    Run(RunArgs),
    Init(InitArgs),
}
```

### Argument Validation
```rust
// Use clap's built-in validation features
#[derive(clap::Args, Debug)]
struct RunArgs {
    #[arg(short, long, default_value_t = 3000)]
    port: u16,
    
    #[arg(long, default_value_t = false)]
    no_overwrite: bool,
}
```

### Custom Styling
```rust
// Implement consistent CLI styling
fn get_styles() -> clap::builder::Styles {
    clap::builder::Styles::styled()
        .header(clap::builder::styling::AnsiColor::Blue.on_default().bold())
        .error(clap::builder::styling::AnsiColor::Red.on_default().bold())
}
```

## Module Organization

### Module Declaration
```rust
// Declare modules at the top of main.rs
mod error;
mod server;
mod storage;
```

### Public Interface Design
```rust
// Expose minimal public API
pub struct Storage {
    // Private fields
    file: String,
    data: StorageData,
    overwrite: bool,
}

impl Storage {
    // Public constructor
    pub fn new(path: &str, overwrite: bool) -> Result<Storage, MocksError> {
        // Implementation
    }
}
```

## Testing Patterns

### Unit Tests in Module
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_socket_addr() {
        let result = parse_socket_addr("localhost", 3000).unwrap();
        assert_eq!(result.ip().to_string(), "127.0.0.1");
        assert_eq!(result.port(), 3000);
    }
}
```

### Integration Test Setup
```rust
// Use tempfile for isolated test environments
#[cfg(test)]
mod integration_tests {
    use tempfile::{NamedTempFile, TempDir};
    
    #[test]
    fn test_storage_operations() {
        let temp_file = NamedTempFile::new().unwrap();
        let storage = Storage::new(temp_file.path().to_str().unwrap(), true).unwrap();
        // Test operations
    }
}
```

## Performance Considerations

### Avoiding String Allocations
```rust
// Use &str when possible to avoid unnecessary allocations
fn process_resource_name(name: &str) -> String {
    if name == "localhost" {
        "127.0.0.1".to_string()
    } else {
        name.to_string()
    }
}
```

### Efficient Collection Operations
```rust
// Use iterator chains for efficient processing
let resources: Vec<String> = data
    .as_object()
    .unwrap()
    .keys()
    .filter(|k| k.starts_with("api/"))
    .map(|k| k.to_string())
    .collect();
```

## Code Quality Guidelines

- Always handle errors explicitly - avoid `.unwrap()` in production code
- Use meaningful variable and function names that describe intent
- Keep functions focused on a single responsibility
- Add documentation comments for public APIs
- Follow Rust naming conventions (snake_case for functions, PascalCase for types)
- Use `cargo fmt` and `cargo clippy` to maintain consistent style
- Write tests for all public functions and error paths